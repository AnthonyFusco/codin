package com.truelaurel.codingame.metaheuristic.evolutionstrategy

import com.truelaurel.codingame.metaheuristic.model.{Problem, Solution}
import com.truelaurel.codingame.time.Chronometer

import scala.concurrent.duration.Duration

/**
  *
  * @param lambda number of children generated by the parents
  * @param mu     number of parents selected
  * @param duration
  */
class MuToLambda(lambda: Int, mu: Int, duration: Duration) {
  require(lambda > 0)
  require(mu > 0 && mu < lambda)

  val chrono = new Chronometer(duration)
  val parentsRange = 0 until lambda
  val tweakedRange = 0 until lambda / mu

  def search[S <: Solution](problem: Problem[S]): S = {
    var parents = parentsRange.map(_ => problem.randomSolution()).sortBy(_.quality())
    var bestSolution = parents.last
    chrono.start()
    while (!chrono.outOfTime) {
      //truncation selection
      val greatest = parents.sortBy(_.quality()).takeRight(mu)
      bestSolution = greatest.last
      parents = greatest.flatMap(s => tweakedRange.map(_ => problem.tweakSolution(s)))
    }
    bestSolution
  }

}
